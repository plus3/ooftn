package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"log"
	"math/rand"
	"os"
	"text/template"
)

const (
	componentsFile = "generated_components.go"
	systemsFile    = "generated_systems.go"
)

func main() {
	componentCount := flag.Int("components", 250, "number of components to generate")
	systemCount := flag.Int("systems", 50, "number of systems to generate")
	flag.Parse()

	log.Printf("Generating %d components and %d systems...\n", *componentCount, *systemCount)

	components := generateComponentData(*componentCount)
	systems := generateSystemData(components, *systemCount)

	generateFile(componentsTemplate, components, componentsFile)
	generateFile(systemsTemplate, systems, systemsFile)

	log.Println("Generation complete.")
}

func generateFile(tmpl *template.Template, data any, path string) {
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		log.Fatalf("failed to execute template for %s: %v", path, err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("failed to format generated code for %s: %v", path, err)
	}

	if err := os.WriteFile(path, formatted, 0644); err != nil {
		log.Fatalf("failed to write generated file %s: %v", path, err)
	}
}

// --- Component Generation ---

type Component struct {
	ID        int
	Name      string
	Fields    []Field
	FieldSize int
}

type Field struct {
	Name string
	Type string
}

var fieldTypes = []struct {
	Type string
	Size int
}{
	{"bool", 1},
	{"int", 8},
	{"int32", 4},
	{"float32", 4},
	{"float64", 8},
	{"[8]byte", 8},
	{"[16]byte", 16},
	{"[32]byte", 32},
}

func generateComponentData(count int) []Component {
	components := make([]Component, count)
	for i := range count {
		numFields := rand.Intn(8) + 1
		fields := make([]Field, numFields)
		totalSize := 0
		for j := range numFields {
			fieldType := fieldTypes[rand.Intn(len(fieldTypes))]
			fields[j] = Field{
				Name: fmt.Sprintf("Field%d", j),
				Type: fieldType.Type,
			}
			totalSize += fieldType.Size
		}
		components[i] = Component{
			ID:        i,
			Name:      fmt.Sprintf("GeneratedComponent%d", i),
			Fields:    fields,
			FieldSize: totalSize,
		}
	}
	return components
}

var componentsTemplate = template.Must(template.New("components").Parse(`// Code generated by ecs-stress/generator. DO NOT EDIT.

package main

import (
	"math/rand"

	"github.com/plus3/ooftn/ecs"
)

{{range .}}
type {{.Name}} struct {
	{{- range .Fields}}
	{{.Name}} {{.Type}}
	{{- end}}
}
{{end}}

func RegisterAllGeneratedComponents(registry *ecs.ComponentRegistry) {
{{- range .}}
	ecs.RegisterComponent[ {{- .Name -}} ](registry)
{{- end}}
}

func SpawnRandomEntity(storage *ecs.Storage, numComponents int) {
	components := make([]any, numComponents)
	for i := 0; i < numComponents; i++ {
		componentID := rand.Intn({{len .}})
		switch componentID {
		{{- range .}}
		case {{.ID}}:
			components[i] = {{.Name}}{}
		{{- end}}
		}
	}
	storage.Spawn(components...)
}
`))

// --- System Generation ---

type System struct {
	ID         int
	Name       string
	Components []Component
}

func generateSystemData(components []Component, count int) []System {
	systems := make([]System, count)
	if len(components) < 2 {
		return systems
	}

	for i := range count {
		// Pick 1 to 4 components for the query
		numComps := rand.Intn(4) + 1
		queryComps := make([]Component, 0, numComps)
		compSet := make(map[int]struct{})

		for range numComps {
			compIdx := rand.Intn(len(components))
			if _, exists := compSet[compIdx]; !exists {
				queryComps = append(queryComps, components[compIdx])
				compSet[compIdx] = struct{}{}
			}
		}

		systems[i] = System{
			ID:         i,
			Name:       fmt.Sprintf("GeneratedSystem%d", i),
			Components: queryComps,
		}
	}
	return systems
}

var systemsTemplate = template.Must(template.New("systems").Parse(`// Code generated by ecs-stress/generator. DO NOT EDIT.

package main

import "github.com/plus3/ooftn/ecs"

{{range .}}
type {{.Name}} struct{
	Entities ecs.Query[struct{
		{{- range .Components}}
		*{{- .Name}}
		{{- end}}
	}]
}

func (s *{{.Name}}) Execute(frame *ecs.UpdateFrame) {
	// In this stress test, we just iterate. A real system would do work.
	for entity := range s.Entities.Values() {
		// Mutate the first component in the query to ensure it's a "write"
		{{- with (index .Components 0)}}
		*entity.{{.Name}} = {{.Name}}{}
		{{- end}}
	}
}
{{end}}

func RegisterAllGeneratedSystems(s *ecs.Scheduler) {
{{- range .}}
	s.Register(&{{.Name}}{})
{{- end}}
}
`))
